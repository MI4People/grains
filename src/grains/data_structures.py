from typing import (Any, Dict, Generator, Iterable, Iterator, List, NamedTuple,
                    Optional, Tuple)

from pydantic import BaseModel, Field


class AstData(NamedTuple):
    filename: str
    tokens: int
    data: Dict[str, Any]


class Topic(BaseModel):
    name: str = Field(..., description="Name of the topic")
    description: str = Field(..., description="Description of the topic")

    def __str__(self) -> str:
        return f"Topic: {self.name}\n    Description: {self.description}"


class Module(BaseModel):
    name: str = Field(..., description="Name of the module")
    topics: List[Topic] = Field(..., description="Topics covered in the module")

    def __str__(self) -> str:
        topics_str = "\n    ".join(str(topic) for topic in self.topics)
        return f"Module: {self.name}\n  Topics:\n    {topics_str}"


class Curriculum(BaseModel):
    modules: List[Module] = Field(..., description="List of modules in the curriculum")

    def __str__(self) -> str:
        modules_str = "\n\n".join(str(module) for module in self.modules)
        return f"Curriculum:\n{modules_str}"


class CategoryMapping(BaseModel):
    module: str = Field(..., description="Module this section maps to")
    topic: str = Field(..., description="Topic this section maps to")
    relevance: float = Field(
        ...,
        description="Relevance score (0-1) indicating how well this section matches the topic",
    )
    cot_justification: str = Field(..., description="Brief explanation of why this section maps to this topic")


class Section(BaseModel):
    title: str = Field(..., description="Title of the section")
    level: int = Field(..., description="Heading level (1-6)")
    content: Optional[str] = Field("", description="Content of the section")
    mappings: List[CategoryMapping] = Field(default_factory=list, description="Category mappings for this section")
    summary: Optional[str] = Field(None, description="Summary of the section content")
    summary_title: Optional[str] = Field(None, description="Section title based on summary")

    def __str__(self) -> str:
        """Returns a markdown representation of the Document object."""
        return f"{self.level*'#'} {self.title}:\n{self.content}"


class Document(BaseModel):
    filename: Optional[str] = Field(None, description="Name of the source file")
    tokens: Optional[int] = Field(None, description="Number of tokens in the document")
    summary: Optional[str] = Field(None, description="Summary of the entire document, generated by an LLM")
    summary_title: Optional[str] = Field(None, description="Document title based on summary")
    sections: List[Section] = Field(
        ...,
        description="Sections of the document as an aggregation of the Sections summaries.",
    )

    def __str__(self) -> str:
        """Returns a markdown representation of the Document object."""
        markdown = f"# {self.filename}\n"
        if self.sections:
            for section in self.sections:
                markdown += str(section) + "\n"  # concatenate the string representation
        return markdown

    @property
    def section_titles(self) -> str:
        """Returns secton titles of the document."""
        return "\n".join([s.title for s in self.sections])
